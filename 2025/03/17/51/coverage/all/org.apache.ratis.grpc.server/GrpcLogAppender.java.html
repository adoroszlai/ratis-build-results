<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GrpcLogAppender.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.ratis.grpc.server</a> &gt; <span class="el_source">GrpcLogAppender.java</span></div><h1>GrpcLogAppender.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.ratis.grpc.server;

import org.apache.ratis.conf.RaftProperties;
import org.apache.ratis.grpc.GrpcConfigKeys;
import org.apache.ratis.grpc.GrpcUtil;
import org.apache.ratis.grpc.metrics.GrpcServerMetrics;
import org.apache.ratis.metrics.Timekeeper;
import org.apache.ratis.proto.RaftProtos.InstallSnapshotResult;
import org.apache.ratis.protocol.RaftPeerId;
import org.apache.ratis.retry.MultipleLinearRandomRetry;
import org.apache.ratis.retry.RetryPolicy;
import org.apache.ratis.server.RaftServer;
import org.apache.ratis.server.RaftServerConfigKeys;
import org.apache.ratis.server.leader.FollowerInfo;
import org.apache.ratis.server.leader.LeaderState;
import org.apache.ratis.server.leader.LogAppenderBase;
import org.apache.ratis.server.protocol.TermIndex;
import org.apache.ratis.server.raftlog.RaftLog;
import org.apache.ratis.server.util.ServerStringUtils;
import org.apache.ratis.thirdparty.io.grpc.StatusRuntimeException;
import org.apache.ratis.thirdparty.io.grpc.stub.CallStreamObserver;
import org.apache.ratis.thirdparty.io.grpc.stub.StreamObserver;
import org.apache.ratis.proto.RaftProtos.AppendEntriesReplyProto;
import org.apache.ratis.proto.RaftProtos.AppendEntriesReplyProto.AppendResult;
import org.apache.ratis.proto.RaftProtos.AppendEntriesRequestProto;
import org.apache.ratis.proto.RaftProtos.InstallSnapshotReplyProto;
import org.apache.ratis.proto.RaftProtos.InstallSnapshotReplyProto.InstallSnapshotReplyBodyCase;
import org.apache.ratis.proto.RaftProtos.InstallSnapshotRequestProto;
import org.apache.ratis.proto.RaftProtos.InstallSnapshotRequestProto.InstallSnapshotRequestBodyCase;
import org.apache.ratis.statemachine.SnapshotInfo;
import org.apache.ratis.util.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InterruptedIOException;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

/**
 * A new log appender implementation using grpc bi-directional stream API.
 */
public class GrpcLogAppender extends LogAppenderBase {
<span class="nc" id="L65">  public static final Logger LOG = LoggerFactory.getLogger(GrpcLogAppender.class);</span>

<span class="nc" id="L67">  private enum BatchLogKey implements BatchLogger.Key {</span>
<span class="nc" id="L68">    RESET_CLIENT,</span>
<span class="nc" id="L69">    INCONSISTENCY_REPLY,</span>
<span class="nc" id="L70">    APPEND_LOG_RESPONSE_HANDLER_ON_ERROR</span>
  }

  public static final int INSTALL_SNAPSHOT_NOTIFICATION_INDEX = 0;

<span class="nc" id="L75">  private static final Comparator&lt;Long&gt; CALL_ID_COMPARATOR = (left, right) -&gt; {</span>
    // calculate diff in order to take care the possibility of numerical overflow
<span class="nc" id="L77">    final long diff = left - right;</span>
<span class="nc bnc" id="L78" title="All 4 branches missed.">    return diff == 0? 0: diff &gt; 0? 1: -1;</span>
  };

<span class="nc" id="L81">  enum Event {</span>
<span class="nc" id="L82">    APPEND_ENTRIES_REPLY,</span>
<span class="nc" id="L83">    APPEND_ENTRIES_INCONSISTENCY_REPLY,</span>
<span class="nc" id="L84">    SNAPSHOT_REPLY,</span>
<span class="nc" id="L85">    COMPLETE,</span>
<span class="nc" id="L86">    TIMEOUT,</span>
<span class="nc" id="L87">    ERROR;</span>

    boolean updateFirstReplyReceived(boolean firstReplyReceived) {
<span class="nc bnc" id="L90" title="All 4 branches missed.">      switch (this) {</span>
        case APPEND_ENTRIES_REPLY:
        case APPEND_ENTRIES_INCONSISTENCY_REPLY:
        case SNAPSHOT_REPLY:
        case COMPLETE:
<span class="nc" id="L95">          return true;</span>
        case ERROR:
<span class="nc" id="L97">          return false;</span>
        case TIMEOUT:
<span class="nc" id="L99">          return firstReplyReceived;</span>
        default:
<span class="nc" id="L101">          throw new IllegalStateException(&quot;Unexpected event: &quot; + this);</span>
      }
    }

    boolean isError() {
<span class="nc bnc" id="L106" title="All 3 branches missed.">      switch (this) {</span>
        case APPEND_ENTRIES_INCONSISTENCY_REPLY:
        case TIMEOUT:
        case ERROR:
<span class="nc" id="L110">          return true;</span>
        case APPEND_ENTRIES_REPLY:
        case SNAPSHOT_REPLY:
        case COMPLETE:
<span class="nc" id="L114">          return false;</span>
        default:
<span class="nc" id="L116">          throw new IllegalStateException(&quot;Unexpected event: &quot; + this);</span>
      }
    }
  }

<span class="nc" id="L121">  static class ReplyState {</span>
<span class="nc" id="L122">    private boolean firstReplyReceived = false;</span>
<span class="nc" id="L123">    private int errorCount = 0;</span>

    synchronized boolean isFirstReplyReceived() {
<span class="nc" id="L126">      return firstReplyReceived;</span>
    }

    synchronized int getErrorCount() {
<span class="nc" id="L130">      return errorCount;</span>
    }

    int process(AppendResult result) {
<span class="nc bnc" id="L134" title="All 2 branches missed.">      return process(result == AppendResult.INCONSISTENCY? Event.APPEND_ENTRIES_INCONSISTENCY_REPLY</span>
          : Event.APPEND_ENTRIES_REPLY);
    }

    synchronized int process(Event event) {
<span class="nc" id="L139">      firstReplyReceived = event.updateFirstReplyReceived(firstReplyReceived);</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">      if (event.isError()) {</span>
<span class="nc" id="L141">        errorCount++;</span>
      } else {
<span class="nc" id="L143">        errorCount = 0;</span>
      }
<span class="nc" id="L145">      return errorCount;</span>
    }
  }

<span class="nc" id="L149">  private final AtomicLong callId = new AtomicLong();</span>

<span class="nc" id="L151">  private final RequestMap pendingRequests = new RequestMap();</span>
  private final int maxPendingRequestsNum;
  private final boolean installSnapshotEnabled;

  private final TimeDuration requestTimeoutDuration;
  private final TimeDuration installSnapshotStreamTimeout;
  private final TimeDuration logMessageBatchDuration;
  private final int maxOutstandingInstallSnapshots;
<span class="nc" id="L159">  private final TimeoutExecutor scheduler = TimeoutExecutor.getInstance();</span>
  @SuppressWarnings({&quot;squid:S3077&quot;}) // Suppress volatile for generic type
  private volatile StreamObservers appendLogRequestObserver;
  private final boolean useSeparateHBChannel;

  private final GrpcServerMetrics grpcServerMetrics;

  private final AutoCloseableReadWriteLock lock;
  private final StackTraceElement caller;
  private final RetryPolicy errorRetryWaitPolicy;
<span class="nc" id="L169">  private final ReplyState replyState = new ReplyState();</span>

  public GrpcLogAppender(RaftServer.Division server, LeaderState leaderState, FollowerInfo f) {
<span class="nc" id="L172">    super(server, leaderState, f);</span>

<span class="nc" id="L174">    Preconditions.assertNotNull(getServerRpc(), &quot;getServerRpc()&quot;);</span>

<span class="nc" id="L176">    final RaftProperties properties = server.getRaftServer().getProperties();</span>
<span class="nc" id="L177">    this.maxPendingRequestsNum = GrpcConfigKeys.Server.leaderOutstandingAppendsMax(properties);</span>
<span class="nc" id="L178">    this.requestTimeoutDuration = RaftServerConfigKeys.Rpc.requestTimeout(properties);</span>
<span class="nc" id="L179">    this.maxOutstandingInstallSnapshots = GrpcConfigKeys.Server.installSnapshotRequestElementLimit(properties);</span>
<span class="nc" id="L180">    this.installSnapshotStreamTimeout = GrpcConfigKeys.Server.installSnapshotRequestTimeout(properties)</span>
<span class="nc" id="L181">        .multiply(maxOutstandingInstallSnapshots);</span>
<span class="nc" id="L182">    this.logMessageBatchDuration = GrpcConfigKeys.Server.logMessageBatchDuration(properties);</span>
<span class="nc" id="L183">    this.installSnapshotEnabled = RaftServerConfigKeys.Log.Appender.installSnapshotEnabled(properties);</span>
<span class="nc" id="L184">    this.useSeparateHBChannel = GrpcConfigKeys.Server.heartbeatChannel(properties);</span>

<span class="nc" id="L186">    grpcServerMetrics = new GrpcServerMetrics(server.getMemberId().toString());</span>
<span class="nc" id="L187">    grpcServerMetrics.addPendingRequestsCount(getFollowerId().toString(), pendingRequests::logRequestsSize);</span>

<span class="nc" id="L189">    lock = new AutoCloseableReadWriteLock(this);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">    caller = LOG.isTraceEnabled()? JavaUtils.getCallerStackTraceElement(): null;</span>
<span class="nc" id="L191">    errorRetryWaitPolicy = MultipleLinearRandomRetry.parseCommaSeparated(</span>
<span class="nc" id="L192">        RaftServerConfigKeys.Log.Appender.retryPolicy(properties));</span>
<span class="nc" id="L193">  }</span>

  @Override
  public GrpcServicesImpl getServerRpc() {
<span class="nc" id="L197">    return (GrpcServicesImpl)super.getServerRpc();</span>
  }

  private GrpcServerProtocolClient getClient() throws IOException {
<span class="nc" id="L201">    return getServerRpc().getProxies().getProxy(getFollowerId());</span>
  }

  private void resetClient(AppendEntriesRequest request, Event event) {
<span class="nc" id="L205">    try (AutoCloseableLock writeLock = lock.writeLock(caller, LOG::trace)) {</span>
<span class="nc" id="L206">      getClient().resetConnectBackoff();</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">      if (appendLogRequestObserver != null) {</span>
<span class="nc" id="L208">        appendLogRequestObserver.stop();</span>
<span class="nc" id="L209">        appendLogRequestObserver = null;</span>
      }
<span class="nc" id="L211">      final int errorCount = replyState.process(event);</span>
      // clear the pending requests queue and reset the next index of follower
<span class="nc" id="L213">      pendingRequests.clear();</span>
<span class="nc" id="L214">      final FollowerInfo f = getFollower();</span>
<span class="nc" id="L215">      final long nextIndex = 1 + Optional.ofNullable(request)</span>
<span class="nc" id="L216">          .map(AppendEntriesRequest::getPreviousLog)</span>
<span class="nc" id="L217">          .map(TermIndex::getIndex)</span>
<span class="nc" id="L218">          .orElseGet(f::getMatchIndex);</span>
<span class="nc bnc" id="L219" title="All 4 branches missed.">      if (event.isError() &amp;&amp; request == null) {</span>
<span class="nc" id="L220">        final long followerNextIndex = f.getNextIndex();</span>
<span class="nc" id="L221">        BatchLogger.print(BatchLogKey.RESET_CLIENT, f.getId() + &quot;-&quot; + followerNextIndex, suffix -&gt;</span>
<span class="nc" id="L222">            LOG.warn(&quot;{}: Follower failed (request=null, errorCount={}); keep nextIndex ({}) unchanged and retry.{}&quot;,</span>
<span class="nc" id="L223">                this, errorCount, followerNextIndex, suffix), logMessageBatchDuration);</span>
<span class="nc" id="L224">        return;</span>
      }
<span class="nc bnc" id="L226" title="All 4 branches missed.">      if (request != null &amp;&amp; request.isHeartbeat()) {</span>
<span class="nc" id="L227">        return;</span>
      }
<span class="nc" id="L229">      getFollower().computeNextIndex(getNextIndexForError(nextIndex));</span>
<span class="nc" id="L230">    } catch (IOException ie) {</span>
<span class="nc" id="L231">      LOG.warn(this + &quot;: Failed to getClient for &quot; + getFollowerId(), ie);</span>
<span class="nc" id="L232">    }</span>
<span class="nc" id="L233">  }</span>

  private boolean isFollowerCommitBehindLastCommitIndex() {
<span class="nc bnc" id="L236" title="All 2 branches missed.">    return getRaftLog().getLastCommittedIndex() &gt; getFollower().getCommitIndex();</span>
  }

  private boolean installSnapshot() {
<span class="nc bnc" id="L240" title="All 2 branches missed.">    if (installSnapshotEnabled) {</span>
<span class="nc" id="L241">      final SnapshotInfo snapshot = shouldInstallSnapshot();</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">      if (snapshot != null) {</span>
<span class="nc" id="L243">        installSnapshot(snapshot);</span>
<span class="nc" id="L244">        return true;</span>
      }
<span class="nc" id="L246">    } else {</span>
      // check installSnapshotNotification
<span class="nc" id="L248">      final TermIndex firstAvailable = shouldNotifyToInstallSnapshot();</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">      if (firstAvailable != null) {</span>
<span class="nc" id="L250">        notifyInstallSnapshot(firstAvailable);</span>
<span class="nc" id="L251">        return true;</span>
      }
    }
<span class="nc" id="L254">    return false;</span>
  }

  @Override
  public void run() throws IOException {
<span class="nc bnc" id="L259" title="All 2 branches missed.">    for(; isRunning(); mayWait()) {</span>
      //HB period is expired OR we have messages OR follower is behind with commit index
<span class="nc bnc" id="L261" title="All 4 branches missed.">      if (shouldSendAppendEntries() || isFollowerCommitBehindLastCommitIndex()) {</span>
<span class="nc" id="L262">        final boolean installingSnapshot = installSnapshot();</span>
<span class="nc bnc" id="L263" title="All 4 branches missed.">        appendLog(installingSnapshot || haveTooManyPendingRequests());</span>
      }
<span class="nc" id="L265">      getLeaderState().checkHealth(getFollower());</span>
    }

<span class="nc" id="L268">    Optional.ofNullable(appendLogRequestObserver).ifPresent(StreamObservers::onCompleted);</span>
<span class="nc" id="L269">  }</span>

  public long getWaitTimeMs() {
<span class="nc bnc" id="L272" title="All 2 branches missed.">    if (haveTooManyPendingRequests()) {</span>
<span class="nc" id="L273">      return getHeartbeatWaitTimeMs(); // Should wait for a short time</span>
<span class="nc bnc" id="L274" title="All 4 branches missed.">    } else if (shouldSendAppendEntries() &amp;&amp; !isSlowFollower()) {</span>
      // For normal nodes, new entries should be sent ASAP
      // however for slow followers (especially when the follower is down),
      // keep sending without any wait time only ends up in high CPU load
<span class="nc" id="L278">      return TimeDuration.max(getRemainingWaitTime(), TimeDuration.ZERO).toLong(TimeUnit.MILLISECONDS);</span>
    }
<span class="nc" id="L280">    return getHeartbeatWaitTimeMs();</span>
  }

  private boolean isSlowFollower() {
<span class="nc" id="L284">    final TimeDuration elapsedTime = getFollower().getLastRpcResponseTime().elapsedTime();</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">    return elapsedTime.compareTo(getServer().properties().rpcSlownessTimeout()) &gt; 0;</span>
  }

  private void mayWait() {
    // use lastSend time instead of lastResponse time
    try {
<span class="nc" id="L291">      getEventAwaitForSignal().await(getWaitTimeMs() + errorWaitTimeMs(),</span>
          TimeUnit.MILLISECONDS);
<span class="nc" id="L293">    } catch (InterruptedException ie) {</span>
<span class="nc" id="L294">      LOG.warn(this + &quot;: Wait interrupted by &quot; + ie);</span>
<span class="nc" id="L295">      Thread.currentThread().interrupt();</span>
<span class="nc" id="L296">    }</span>
<span class="nc" id="L297">  }</span>

  private long errorWaitTimeMs() {
<span class="nc" id="L300">    return errorRetryWaitPolicy.handleAttemptFailure(replyState::getErrorCount)</span>
<span class="nc" id="L301">        .getSleepTime().toLong(TimeUnit.MILLISECONDS);</span>
  }

  @Override
  public CompletableFuture&lt;LifeCycle.State&gt; stopAsync() {
<span class="nc" id="L306">    try (AutoCloseableLock ignored = lock.writeLock(caller, LOG::trace)) {</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">      if (appendLogRequestObserver != null) {</span>
<span class="nc" id="L308">        appendLogRequestObserver.stop();</span>
<span class="nc" id="L309">        appendLogRequestObserver = null;</span>
      }
<span class="nc" id="L311">      grpcServerMetrics.unregister();</span>
<span class="nc" id="L312">      return super.stopAsync();</span>
    }
  }

  @Override
  public boolean shouldSendAppendEntries() {
<span class="nc bnc" id="L318" title="All 4 branches missed.">    return appendLogRequestObserver == null || super.shouldSendAppendEntries();</span>
  }

  @Override
  public boolean hasPendingDataRequests() {
<span class="nc bnc" id="L323" title="All 2 branches missed.">    return pendingRequests.logRequestsSize() &gt; 0;</span>
  }

  /** @return true iff either (1) queue is full, or (2) queue is non-empty and not received first response. */
  private boolean haveTooManyPendingRequests() {
<span class="nc" id="L328">    final int size = pendingRequests.logRequestsSize();</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">    if (size == 0) {</span>
<span class="nc" id="L330">      return false;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">    } else if (size &gt;= maxPendingRequestsNum) {</span>
<span class="nc" id="L332">      return true;</span>
    } else {
      // queue is non-empty and non-full
<span class="nc bnc" id="L335" title="All 2 branches missed.">      return !replyState.isFirstReplyReceived();</span>
    }
  }

  static class StreamObservers {
    private final CallStreamObserver&lt;AppendEntriesRequestProto&gt; appendLog;
    private final CallStreamObserver&lt;AppendEntriesRequestProto&gt; heartbeat;
    private final TimeDuration waitForReady;
<span class="nc" id="L343">    private volatile boolean running = true;</span>

    StreamObservers(GrpcServerProtocolClient client, AppendLogResponseHandler handler, boolean separateHeartbeat,
<span class="nc" id="L346">        TimeDuration waitTimeMin) {</span>
<span class="nc" id="L347">      this.appendLog = client.appendEntries(handler, false);</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">      this.heartbeat = separateHeartbeat? client.appendEntries(handler, true): null;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">      this.waitForReady = waitTimeMin.isPositive()? waitTimeMin: TimeDuration.ONE_MILLISECOND;</span>
<span class="nc" id="L350">    }</span>

    void onNext(AppendEntriesRequestProto proto)
        throws InterruptedIOException {
      CallStreamObserver&lt;AppendEntriesRequestProto&gt; stream;
<span class="nc bnc" id="L355" title="All 4 branches missed.">      boolean isHeartBeat = heartbeat != null &amp;&amp; proto.getEntriesCount() == 0;</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">      if (isHeartBeat) {</span>
<span class="nc" id="L357">        stream = heartbeat;</span>
      } else {
<span class="nc" id="L359">        stream = appendLog;</span>
      }
      // stall for stream to be ready.
<span class="nc bnc" id="L362" title="All 4 branches missed.">      while (!stream.isReady() &amp;&amp; running) {</span>
<span class="nc" id="L363">        sleep(waitForReady, isHeartBeat);</span>
      }
<span class="nc" id="L365">      stream.onNext(proto);</span>
<span class="nc" id="L366">    }</span>

    void stop() {
<span class="nc" id="L369">      running = false;</span>
<span class="nc" id="L370">    }</span>

    void onCompleted() {
<span class="nc" id="L373">      appendLog.onCompleted();</span>
<span class="nc" id="L374">      Optional.ofNullable(heartbeat).ifPresent(StreamObserver::onCompleted);</span>
<span class="nc" id="L375">    }</span>
  }

  @Override
  public long getCallId() {
<span class="nc" id="L380">    return callId.get();</span>
  }

  @Override
  public Comparator&lt;Long&gt; getCallIdComparator() {
<span class="nc" id="L385">    return CALL_ID_COMPARATOR;</span>
  }

  private void appendLog(boolean heartbeat) throws IOException {
    final ReferenceCountedObject&lt;AppendEntriesRequestProto&gt; pending;
    final AppendEntriesRequest request;
<span class="nc" id="L391">    try (AutoCloseableLock writeLock = lock.writeLock(caller, LOG::trace)) {</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">      if (!isRunning()) {</span>
<span class="nc" id="L393">        return;</span>
      }
      // Prepare and send the append request.
      // Note changes on follower's nextIndex and ops on pendingRequests should always be done under the write-lock
<span class="nc" id="L397">      pending = nextAppendEntriesRequest(callId.getAndIncrement(), heartbeat);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">      if (pending == null) {</span>
<span class="nc" id="L399">        return;</span>
      }
      try {
<span class="nc" id="L402">        request = new AppendEntriesRequest(pending.get(), getFollowerId(), grpcServerMetrics);</span>
<span class="nc" id="L403">        pendingRequests.put(request);</span>
<span class="nc" id="L404">        increaseNextIndex(pending.get());</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (appendLogRequestObserver == null) {</span>
<span class="nc" id="L406">          appendLogRequestObserver = new StreamObservers(</span>
<span class="nc" id="L407">              getClient(), new AppendLogResponseHandler(), useSeparateHBChannel, getWaitTimeMin());</span>
        }
<span class="nc" id="L409">      } catch (Exception e) {</span>
<span class="nc" id="L410">        pending.release();</span>
<span class="nc" id="L411">        throw e;</span>
<span class="nc" id="L412">      }</span>
    }

    try {
<span class="nc" id="L416">      final TimeDuration remaining = getRemainingWaitTime();</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">      if (remaining.isPositive()) {</span>
<span class="nc" id="L418">        sleep(remaining, heartbeat);</span>
      }
<span class="nc bnc" id="L420" title="All 2 branches missed.">      if (isRunning()) {</span>
<span class="nc" id="L421">        sendRequest(request, pending.get());</span>
      }
    } finally {
<span class="nc" id="L424">      pending.release();</span>
    }
<span class="nc" id="L426">  }</span>

  private static void sleep(TimeDuration waitTime, boolean heartbeat)
      throws InterruptedIOException {
    try {
<span class="nc" id="L431">      waitTime.sleep();</span>
<span class="nc" id="L432">    } catch (InterruptedException e) {</span>
<span class="nc" id="L433">      Thread.currentThread().interrupt();</span>
<span class="nc" id="L434">      throw IOUtils.toInterruptedIOException(</span>
          &quot;Interrupted appendLog, heartbeat? &quot; + heartbeat, e);
<span class="nc" id="L436">    }</span>
<span class="nc" id="L437">  }</span>

  private void sendRequest(AppendEntriesRequest request,
      AppendEntriesRequestProto proto) throws InterruptedIOException {
<span class="nc" id="L441">    CodeInjectionForTesting.execute(GrpcServicesImpl.GRPC_SEND_SERVER_REQUEST,</span>
<span class="nc" id="L442">        getServer().getId(), null, proto);</span>
<span class="nc" id="L443">    resetHeartbeatTrigger();</span>

<span class="nc" id="L445">    StreamObservers observers = appendLogRequestObserver;</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">    if (observers != null) {</span>
<span class="nc" id="L447">      request.startRequestTimer();</span>
<span class="nc" id="L448">      observers.onNext(proto);</span>
<span class="nc" id="L449">      getFollower().updateLastRpcSendTime(request.isHeartbeat());</span>
<span class="nc" id="L450">      scheduler.onTimeout(requestTimeoutDuration,</span>
<span class="nc" id="L451">          () -&gt; timeoutAppendRequest(request.getCallId(), request.isHeartbeat()),</span>
<span class="nc" id="L452">          LOG, () -&gt; &quot;Timeout check failed for append entry request: &quot; + request);</span>
    }
<span class="nc" id="L454">  }</span>

  private void timeoutAppendRequest(long cid, boolean heartbeat) {
<span class="nc" id="L457">    final AppendEntriesRequest pending = pendingRequests.remove(cid, heartbeat);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">    if (pending != null) {</span>
<span class="nc" id="L459">      final int errorCount = replyState.process(Event.TIMEOUT);</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">      LOG.warn(&quot;{}: Timed out {}appendEntries, errorCount={}, request={}&quot;,</span>
<span class="nc" id="L461">          this, heartbeat ? &quot;HEARTBEAT &quot; : &quot;&quot;, errorCount, pending);</span>
<span class="nc" id="L462">      grpcServerMetrics.onRequestTimeout(getFollowerId().toString(), heartbeat);</span>
<span class="nc" id="L463">      pending.stopRequestTimer();</span>
    }
<span class="nc" id="L465">  }</span>

  private void increaseNextIndex(AppendEntriesRequestProto request) {
<span class="nc" id="L468">    final int count = request.getEntriesCount();</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">    if (count &gt; 0) {</span>
<span class="nc" id="L470">      getFollower().increaseNextIndex(request.getEntries(count - 1).getIndex() + 1);</span>
    }
<span class="nc" id="L472">  }</span>

  private void increaseNextIndex(final long installedSnapshotIndex, Object reason) {
<span class="nc" id="L475">    final long newNextIndex = installedSnapshotIndex + 1;</span>
<span class="nc" id="L476">    LOG.info(&quot;{}: updateNextIndex {} for {}&quot;, this, newNextIndex, reason);</span>
<span class="nc" id="L477">    getFollower().updateNextIndex(newNextIndex);</span>
<span class="nc" id="L478">  }</span>

  /**
   * StreamObserver for handling responses from the follower
   */
<span class="nc" id="L483">  private class AppendLogResponseHandler implements StreamObserver&lt;AppendEntriesReplyProto&gt; {</span>
<span class="nc" id="L484">    private final String name = getFollower().getName() + &quot;-&quot; + JavaUtils.getClassSimpleName(getClass());</span>

    /**
     * After receiving a appendEntries reply, do the following:
     * 1. If the reply is success, update the follower's match index and submit
     *    an event to leaderState
     * 2. If the reply is NOT_LEADER, step down
     * 3. If the reply is INCONSISTENCY, increase/ decrease the follower's next
     *    index based on the response
     */
    @Override
    public void onNext(AppendEntriesReplyProto reply) {
<span class="nc" id="L496">      AppendEntriesRequest request = pendingRequests.remove(reply);</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">      if (request != null) {</span>
<span class="nc" id="L498">        request.stopRequestTimer(); // Update completion time</span>
<span class="nc" id="L499">        getFollower().updateLastRespondedAppendEntriesSendTime(request.getSendTime());</span>
      }
<span class="nc" id="L501">      getFollower().updateLastRpcResponseTime();</span>

<span class="nc bnc" id="L503" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L504">        LOG.debug(&quot;{}: received {} reply {}, request={}&quot;,</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">            this, replyState.isFirstReplyReceived()? &quot;a&quot;: &quot;the first&quot;,</span>
<span class="nc" id="L506">            ServerStringUtils.toAppendEntriesReplyString(reply), request);</span>
      }

      try {
<span class="nc" id="L510">        onNextImpl(request, reply);</span>
<span class="nc" id="L511">      } catch(Exception t) {</span>
<span class="nc" id="L512">        LOG.error(&quot;Failed onNext request=&quot; + request</span>
<span class="nc" id="L513">            + &quot;, reply=&quot; + ServerStringUtils.toAppendEntriesReplyString(reply), t);</span>
<span class="nc" id="L514">      }</span>
<span class="nc" id="L515">    }</span>

    private void onNextImpl(AppendEntriesRequest request, AppendEntriesReplyProto reply) {
<span class="nc" id="L518">      final int errorCount = replyState.process(reply.getResult());</span>

<span class="nc bnc" id="L520" title="All 4 branches missed.">      switch (reply.getResult()) {</span>
        case SUCCESS:
<span class="nc" id="L522">          grpcServerMetrics.onRequestSuccess(getFollowerId().toString(), reply.getIsHearbeat());</span>
<span class="nc" id="L523">          getLeaderState().onFollowerCommitIndex(getFollower(), reply.getFollowerCommit());</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">          if (getFollower().updateMatchIndex(reply.getMatchIndex())) {</span>
<span class="nc" id="L525">            getFollower().updateNextIndex(reply.getMatchIndex() + 1);</span>
<span class="nc" id="L526">            getLeaderState().onFollowerSuccessAppendEntries(getFollower());</span>
          }
          break;
        case NOT_LEADER:
<span class="nc" id="L530">          grpcServerMetrics.onRequestNotLeader(getFollowerId().toString());</span>
<span class="nc" id="L531">          LOG.warn(&quot;{}: received {} reply with term {}&quot;, this, reply.getResult(), reply.getTerm());</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">          if (onFollowerTerm(reply.getTerm())) {</span>
<span class="nc" id="L533">            return;</span>
          }
          break;
        case INCONSISTENCY:
<span class="nc" id="L537">          grpcServerMetrics.onRequestInconsistency(getFollowerId().toString());</span>
<span class="nc" id="L538">          BatchLogger.print(BatchLogKey.INCONSISTENCY_REPLY, getFollower().getName() + &quot;_&quot; + reply.getNextIndex(),</span>
<span class="nc" id="L539">              suffix -&gt; LOG.warn(&quot;{}: received {} reply with nextIndex {}, errorCount={}, request={} {}&quot;,</span>
<span class="nc" id="L540">              this, reply.getResult(), reply.getNextIndex(), errorCount, request, suffix));</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">          final long requestFirstIndex = request != null? request.getFirstIndex(): RaftLog.INVALID_LOG_INDEX;</span>
<span class="nc" id="L542">          updateNextIndex(getNextIndexForInconsistency(requestFirstIndex, reply.getNextIndex()));</span>
<span class="nc" id="L543">          break;</span>
        default:
<span class="nc" id="L545">          throw new IllegalStateException(&quot;Unexpected reply result: &quot; + reply.getResult());</span>
      }
<span class="nc" id="L547">      getLeaderState().onAppendEntriesReply(GrpcLogAppender.this, reply);</span>
<span class="nc" id="L548">      notifyLogAppender();</span>
<span class="nc" id="L549">    }</span>

    /**
     * for now we simply retry the first pending request
     */
    @Override
    public void onError(Throwable t) {
<span class="nc bnc" id="L556" title="All 2 branches missed.">      if (!isRunning()) {</span>
<span class="nc" id="L557">        LOG.info(&quot;{} is already stopped&quot;, GrpcLogAppender.this);</span>
<span class="nc" id="L558">        return;</span>
      }
<span class="nc" id="L560">      BatchLogger.print(BatchLogKey.APPEND_LOG_RESPONSE_HANDLER_ON_ERROR, AppendLogResponseHandler.this.name,</span>
<span class="nc" id="L561">          suffix -&gt; GrpcUtil.warn(LOG, () -&gt; this + &quot;: Failed appendEntries&quot; + suffix, t),</span>
<span class="nc" id="L562">          logMessageBatchDuration, t instanceof StatusRuntimeException);</span>
<span class="nc" id="L563">      grpcServerMetrics.onRequestRetry(); // Update try counter</span>
<span class="nc" id="L564">      AppendEntriesRequest request = pendingRequests.remove(GrpcUtil.getCallId(t), GrpcUtil.isHeartbeat(t));</span>
<span class="nc" id="L565">      resetClient(request, Event.ERROR);</span>
<span class="nc" id="L566">    }</span>

    @Override
    public void onCompleted() {
<span class="nc" id="L570">      LOG.info(&quot;{}: follower responses appendEntries COMPLETED&quot;, this);</span>
<span class="nc" id="L571">      resetClient(null, Event.COMPLETE);</span>
<span class="nc" id="L572">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L576">      return name;</span>
    }
  }

  private void updateNextIndex(long replyNextIndex) {
<span class="nc" id="L581">    try (AutoCloseableLock writeLock = lock.writeLock(caller, LOG::trace)) {</span>
<span class="nc" id="L582">      pendingRequests.clear();</span>
<span class="nc" id="L583">      getFollower().setNextIndex(replyNextIndex);</span>
    }
<span class="nc" id="L585">  }</span>

  private class InstallSnapshotResponseHandler implements StreamObserver&lt;InstallSnapshotReplyProto&gt; {
<span class="nc" id="L588">    private final String name = getFollower().getName() + &quot;-&quot; + JavaUtils.getClassSimpleName(getClass());</span>
    private final Queue&lt;Integer&gt; pending;
<span class="nc" id="L590">    private final CompletableFuture&lt;Void&gt; done = new CompletableFuture&lt;&gt;();</span>
    private final boolean isNotificationOnly;

    InstallSnapshotResponseHandler() {
<span class="nc" id="L594">      this(false);</span>
<span class="nc" id="L595">    }</span>

<span class="nc" id="L597">    InstallSnapshotResponseHandler(boolean notifyOnly) {</span>
<span class="nc" id="L598">      pending = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L599">      this.isNotificationOnly = notifyOnly;</span>
<span class="nc" id="L600">    }</span>

    void addPending(InstallSnapshotRequestProto request) {
<span class="nc" id="L603">      try (AutoCloseableLock writeLock = lock.writeLock(caller, LOG::trace)) {</span>
        final int index;
<span class="nc bnc" id="L605" title="All 2 branches missed.">        if (isNotificationOnly) {</span>
<span class="nc" id="L606">          Preconditions.assertSame(InstallSnapshotRequestBodyCase.NOTIFICATION,</span>
<span class="nc" id="L607">                  request.getInstallSnapshotRequestBodyCase(), &quot;request case&quot;);</span>
<span class="nc" id="L608">          index = INSTALL_SNAPSHOT_NOTIFICATION_INDEX;</span>
        } else {
<span class="nc" id="L610">          Preconditions.assertSame(InstallSnapshotRequestBodyCase.SNAPSHOTCHUNK,</span>
<span class="nc" id="L611">                  request.getInstallSnapshotRequestBodyCase(), &quot;request case&quot;);</span>
<span class="nc" id="L612">          index = request.getSnapshotChunk().getRequestIndex();</span>
        }
<span class="nc bnc" id="L614" title="All 2 branches missed.">        if (index == 0) {</span>
<span class="nc" id="L615">          Preconditions.assertTrue(pending.isEmpty(), &quot;pending queue is non-empty before offer for index 0&quot;);</span>
        }
<span class="nc" id="L617">        pending.offer(index);</span>
      }
<span class="nc" id="L619">    }</span>

    void removePending(InstallSnapshotReplyProto reply) {
<span class="nc" id="L622">      try (AutoCloseableLock writeLock = lock.writeLock(caller, LOG::trace)) {</span>
<span class="nc" id="L623">        final int index = Objects.requireNonNull(pending.poll(), &quot;index == null&quot;);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">        if (isNotificationOnly) {</span>
<span class="nc" id="L625">          Preconditions.assertSame(InstallSnapshotReplyBodyCase.SNAPSHOTINDEX,</span>
<span class="nc" id="L626">                  reply.getInstallSnapshotReplyBodyCase(), &quot;reply case&quot;);</span>
<span class="nc" id="L627">          Preconditions.assertSame(INSTALL_SNAPSHOT_NOTIFICATION_INDEX, (int) index, &quot;poll index&quot;);</span>
        } else {
<span class="nc" id="L629">          Preconditions.assertSame(InstallSnapshotReplyBodyCase.REQUESTINDEX,</span>
<span class="nc" id="L630">                  reply.getInstallSnapshotReplyBodyCase(), &quot;reply case&quot;);</span>
<span class="nc" id="L631">          Preconditions.assertSame(reply.getRequestIndex(), (int) index, &quot;poll index&quot;);</span>
        }
      }
<span class="nc" id="L634">    }</span>

    //compare follower's latest installed snapshot index with leader's start index
    void onFollowerCatchup(long followerSnapshotIndex) {
<span class="nc" id="L638">      final long leaderStartIndex = getRaftLog().getStartIndex();</span>
<span class="nc" id="L639">      final long followerNextIndex = followerSnapshotIndex + 1;</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">      if (followerNextIndex &gt;= leaderStartIndex) {</span>
<span class="nc" id="L641">        LOG.info(&quot;{}: Follower can catch up leader after install the snapshot, as leader's start index is {}&quot;,</span>
<span class="nc" id="L642">            this, followerNextIndex);</span>
<span class="nc" id="L643">        notifyInstallSnapshotFinished(InstallSnapshotResult.SUCCESS, followerSnapshotIndex);</span>
      }
<span class="nc" id="L645">    }</span>

    void notifyInstallSnapshotFinished(InstallSnapshotResult result, long snapshotIndex) {
<span class="nc" id="L648">      getServer().getStateMachine().event().notifySnapshotInstalled(result, snapshotIndex, getFollower().getPeer());</span>
<span class="nc" id="L649">    }</span>

    void waitForResponse() {
      try {
<span class="nc" id="L653">        done.get();</span>
<span class="nc" id="L654">      } catch (InterruptedException e) {</span>
<span class="nc" id="L655">        Thread.currentThread().interrupt();</span>
<span class="nc" id="L656">      } catch (ExecutionException e) {</span>
<span class="nc" id="L657">        throw new IllegalStateException(&quot;Failed to complete &quot; + name, e);</span>
<span class="nc" id="L658">      }</span>
<span class="nc" id="L659">    }</span>

    void close() {
<span class="nc" id="L662">      done.complete(null);</span>
<span class="nc" id="L663">      notifyLogAppender();</span>
<span class="nc" id="L664">    }</span>

    boolean hasAllResponse() {
<span class="nc" id="L667">      try (AutoCloseableLock readLock = lock.readLock(caller, LOG::trace)) {</span>
<span class="nc" id="L668">        return pending.isEmpty();</span>
      }
    }

    @Override
    public void onNext(InstallSnapshotReplyProto reply) {
<span class="nc bnc" id="L674" title="All 2 branches missed.">      if (LOG.isInfoEnabled()) {</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">        LOG.info(&quot;{}: received {} reply {}&quot;, this, replyState.isFirstReplyReceived()? &quot;a&quot; : &quot;the first&quot;,</span>
<span class="nc" id="L676">            ServerStringUtils.toInstallSnapshotReplyString(reply));</span>
      }

      // update the last rpc time
<span class="nc" id="L680">      getFollower().updateLastRpcResponseTime();</span>
<span class="nc" id="L681">      replyState.process(Event.SNAPSHOT_REPLY);</span>

      final long followerSnapshotIndex;
<span class="nc bnc" id="L684" title="All 10 branches missed.">      switch (reply.getResult()) {</span>
        case SUCCESS:
<span class="nc" id="L686">          LOG.info(&quot;{}: Completed InstallSnapshot. Reply: {}&quot;, this, reply);</span>
<span class="nc" id="L687">          getFollower().setAttemptedToInstallSnapshot();</span>
<span class="nc" id="L688">          removePending(reply);</span>
<span class="nc" id="L689">          break;</span>
        case IN_PROGRESS:
<span class="nc" id="L691">          LOG.info(&quot;{}: InstallSnapshot in progress.&quot;, this);</span>
<span class="nc" id="L692">          removePending(reply);</span>
<span class="nc" id="L693">          break;</span>
        case ALREADY_INSTALLED:
<span class="nc" id="L695">          followerSnapshotIndex = reply.getSnapshotIndex();</span>
<span class="nc" id="L696">          LOG.info(&quot;{}: Follower snapshot is already at index {}.&quot;, this, followerSnapshotIndex);</span>
<span class="nc" id="L697">          getFollower().setSnapshotIndex(followerSnapshotIndex);</span>
<span class="nc" id="L698">          getFollower().setAttemptedToInstallSnapshot();</span>
<span class="nc" id="L699">          getLeaderState().onFollowerCommitIndex(getFollower(), followerSnapshotIndex);</span>
<span class="nc" id="L700">          increaseNextIndex(followerSnapshotIndex, reply.getResult());</span>
<span class="nc" id="L701">          removePending(reply);</span>
<span class="nc" id="L702">          break;</span>
        case NOT_LEADER:
<span class="nc" id="L704">          onFollowerTerm(reply.getTerm());</span>
<span class="nc" id="L705">          break;</span>
        case CONF_MISMATCH:
<span class="nc" id="L707">          LOG.error(&quot;{}: Configuration Mismatch ({}): Leader {} has it set to {} but follower {} has it set to {}&quot;,</span>
              this, RaftServerConfigKeys.Log.Appender.INSTALL_SNAPSHOT_ENABLED_KEY,
<span class="nc bnc" id="L709" title="All 2 branches missed.">              getServer().getId(), installSnapshotEnabled, getFollowerId(), !installSnapshotEnabled);</span>
<span class="nc" id="L710">          break;</span>
        case SNAPSHOT_INSTALLED:
<span class="nc" id="L712">          followerSnapshotIndex = reply.getSnapshotIndex();</span>
<span class="nc" id="L713">          LOG.info(&quot;{}: Follower installed snapshot at index {}&quot;, this, followerSnapshotIndex);</span>
<span class="nc" id="L714">          getFollower().setSnapshotIndex(followerSnapshotIndex);</span>
<span class="nc" id="L715">          getFollower().setAttemptedToInstallSnapshot();</span>
<span class="nc" id="L716">          getLeaderState().onFollowerCommitIndex(getFollower(), followerSnapshotIndex);</span>
<span class="nc" id="L717">          increaseNextIndex(followerSnapshotIndex, reply.getResult());</span>
<span class="nc" id="L718">          onFollowerCatchup(followerSnapshotIndex);</span>
<span class="nc" id="L719">          removePending(reply);</span>
<span class="nc" id="L720">          break;</span>
        case SNAPSHOT_UNAVAILABLE:
<span class="nc" id="L722">          LOG.info(&quot;{}: Follower could not install snapshot as it is not available.&quot;, this);</span>
<span class="nc" id="L723">          getFollower().setAttemptedToInstallSnapshot();</span>
<span class="nc" id="L724">          notifyInstallSnapshotFinished(InstallSnapshotResult.SNAPSHOT_UNAVAILABLE, RaftLog.INVALID_LOG_INDEX);</span>
<span class="nc" id="L725">          removePending(reply);</span>
<span class="nc" id="L726">          break;</span>
        case UNRECOGNIZED:
<span class="nc" id="L728">          LOG.error(&quot;Unrecognized the reply result {}: Leader is {}, follower is {}&quot;,</span>
<span class="nc" id="L729">              reply.getResult(), getServer().getId(), getFollowerId());</span>
<span class="nc" id="L730">          break;</span>
        case SNAPSHOT_EXPIRED:
<span class="nc" id="L732">          LOG.warn(&quot;{}: Follower could not install snapshot as it is expired.&quot;, this);</span>
        default:
          break;
      }
<span class="nc" id="L736">    }</span>

    @Override
    public void onError(Throwable t) {
<span class="nc bnc" id="L740" title="All 2 branches missed.">      if (!isRunning()) {</span>
<span class="nc" id="L741">        LOG.info(&quot;{} is stopped&quot;, GrpcLogAppender.this);</span>
<span class="nc" id="L742">        return;</span>
      }
<span class="nc" id="L744">      GrpcUtil.warn(LOG, () -&gt; this + &quot;: Failed InstallSnapshot&quot;, t);</span>
<span class="nc" id="L745">      grpcServerMetrics.onRequestRetry(); // Update try counter</span>
<span class="nc" id="L746">      resetClient(null, Event.ERROR);</span>
<span class="nc" id="L747">      close();</span>
<span class="nc" id="L748">    }</span>

    @Override
    public void onCompleted() {
<span class="nc bnc" id="L752" title="All 4 branches missed.">      if (!isNotificationOnly || LOG.isDebugEnabled()) {</span>
<span class="nc" id="L753">        LOG.info(&quot;{}: follower responded installSnapshot COMPLETED&quot;, this);</span>
      }
<span class="nc" id="L755">      replyState.process(Event.COMPLETE);</span>
<span class="nc" id="L756">      close();</span>
<span class="nc" id="L757">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L761">      return name;</span>
    }
  }

  /**
   * Send installSnapshot request to Follower with a snapshot.
   * @param snapshot the snapshot to be sent to Follower
   */
  private void installSnapshot(SnapshotInfo snapshot) {
<span class="nc" id="L770">    LOG.info(&quot;{}: followerNextIndex = {} but logStartIndex = {}, send snapshot {} to follower&quot;,</span>
<span class="nc" id="L771">        this, getFollower().getNextIndex(), getRaftLog().getStartIndex(), snapshot);</span>

<span class="nc" id="L773">    final InstallSnapshotResponseHandler responseHandler = new InstallSnapshotResponseHandler();</span>
<span class="nc" id="L774">    StreamObserver&lt;InstallSnapshotRequestProto&gt; snapshotRequestObserver = null;</span>
<span class="nc" id="L775">    final String requestId = UUID.randomUUID().toString();</span>
    try {
<span class="nc" id="L777">      snapshotRequestObserver = getClient().installSnapshot(</span>
<span class="nc" id="L778">          getFollower().getName() + &quot;-installSnapshot-&quot; + requestId,</span>
          installSnapshotStreamTimeout, maxOutstandingInstallSnapshots, responseHandler);
<span class="nc bnc" id="L780" title="All 2 branches missed.">      for (InstallSnapshotRequestProto request : newInstallSnapshotRequests(requestId, snapshot)) {</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">        if (isRunning()) {</span>
<span class="nc" id="L782">          snapshotRequestObserver.onNext(request);</span>
<span class="nc" id="L783">          getFollower().updateLastRpcSendTime(false);</span>
<span class="nc" id="L784">          responseHandler.addPending(request);</span>
        } else {
          break;
        }
<span class="nc" id="L788">      }</span>
<span class="nc" id="L789">      snapshotRequestObserver.onCompleted();</span>
<span class="nc" id="L790">      grpcServerMetrics.onInstallSnapshot();</span>
<span class="nc" id="L791">    } catch (Exception e) {</span>
<span class="nc" id="L792">      LOG.warn(this + &quot;: failed to installSnapshot &quot; + snapshot, e);</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">      if (snapshotRequestObserver != null) {</span>
<span class="nc" id="L794">        snapshotRequestObserver.onError(e);</span>
      }
<span class="nc" id="L796">      return;</span>
<span class="nc" id="L797">    }</span>
<span class="nc" id="L798">    responseHandler.waitForResponse();</span>

<span class="nc bnc" id="L800" title="All 2 branches missed.">    if (responseHandler.hasAllResponse()) {</span>
<span class="nc" id="L801">      getFollower().setSnapshotIndex(snapshot.getTermIndex().getIndex());</span>
<span class="nc" id="L802">      LOG.info(&quot;{}: installed snapshot {} successfully&quot;, this, snapshot);</span>
    }
<span class="nc" id="L804">  }</span>

  /**
   * Send an installSnapshot notification request to the Follower.
   * @param firstAvailable the first available log's index on the Leader
   */
  private void notifyInstallSnapshot(TermIndex firstAvailable) {
<span class="nc" id="L811">    LOG.info(&quot;{}: notifyInstallSnapshot with firstAvailable={}, followerNextIndex={}&quot;,</span>
<span class="nc" id="L812">        this, firstAvailable, getFollower().getNextIndex());</span>

<span class="nc" id="L814">    final InstallSnapshotResponseHandler responseHandler = new InstallSnapshotResponseHandler(true);</span>
<span class="nc" id="L815">    StreamObserver&lt;InstallSnapshotRequestProto&gt; snapshotRequestObserver = null;</span>
    // prepare and enqueue the notify install snapshot request.
<span class="nc" id="L817">    final InstallSnapshotRequestProto request = newInstallSnapshotNotificationRequest(firstAvailable);</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">    if (LOG.isInfoEnabled()) {</span>
<span class="nc" id="L819">      LOG.info(&quot;{}: send {}&quot;, this, ServerStringUtils.toInstallSnapshotRequestString(request));</span>
    }
    try {
<span class="nc" id="L822">      snapshotRequestObserver = getClient().installSnapshot(getFollower().getName() + &quot;-notifyInstallSnapshot&quot;,</span>
          requestTimeoutDuration, 0, responseHandler);

<span class="nc" id="L825">      snapshotRequestObserver.onNext(request);</span>
<span class="nc" id="L826">      getFollower().updateLastRpcSendTime(false);</span>
<span class="nc" id="L827">      responseHandler.addPending(request);</span>
<span class="nc" id="L828">      snapshotRequestObserver.onCompleted();</span>
<span class="nc" id="L829">    } catch (Exception e) {</span>
<span class="nc" id="L830">      GrpcUtil.warn(LOG, () -&gt; this + &quot;: Failed to notify follower to install snapshot.&quot;, e);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">      if (snapshotRequestObserver != null) {</span>
<span class="nc" id="L832">        snapshotRequestObserver.onError(e);</span>
      }
<span class="nc" id="L834">      return;</span>
<span class="nc" id="L835">    }</span>
<span class="nc" id="L836">    responseHandler.waitForResponse();</span>
<span class="nc" id="L837">  }</span>

  /**
   * Should the Leader notify the Follower to install the snapshot through
   * its own State Machine.
   * @return the first available log's start term index
   */
  private TermIndex shouldNotifyToInstallSnapshot() {
<span class="nc" id="L845">    final FollowerInfo follower = getFollower();</span>
<span class="nc" id="L846">    final long leaderNextIndex = getRaftLog().getNextIndex();</span>
<span class="nc" id="L847">    final boolean isFollowerBootstrapping = getLeaderState().isFollowerBootstrapping(follower);</span>
<span class="nc" id="L848">    final long leaderStartIndex = getRaftLog().getStartIndex();</span>
<span class="nc" id="L849">    final TermIndex firstAvailable = Optional.ofNullable(getRaftLog().getTermIndex(leaderStartIndex))</span>
<span class="nc" id="L850">        .orElseGet(() -&gt; TermIndex.valueOf(getServer().getInfo().getCurrentTerm(), leaderNextIndex));</span>
<span class="nc bnc" id="L851" title="All 4 branches missed.">    if (isFollowerBootstrapping &amp;&amp; !follower.hasAttemptedToInstallSnapshot()) {</span>
      // If the follower is bootstrapping and has not yet installed any snapshot from leader, then the follower should
      // be notified to install a snapshot. Every follower should try to install at least one snapshot during
      // bootstrapping, if available.
<span class="nc" id="L855">      LOG.debug(&quot;{}: follower is bootstrapping, notify to install snapshot to {}.&quot;, this, firstAvailable);</span>
<span class="nc" id="L856">      return firstAvailable;</span>
    }

<span class="nc" id="L859">    final long followerNextIndex = follower.getNextIndex();</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">    if (followerNextIndex &gt;= leaderNextIndex) {</span>
<span class="nc" id="L861">      return null;</span>
    }

<span class="nc bnc" id="L864" title="All 2 branches missed.">    if (followerNextIndex &lt; leaderStartIndex) {</span>
      // The Leader does not have the logs from the Follower's last log
      // index onwards. And install snapshot is disabled. So the Follower
      // should be notified to install the latest snapshot through its
      // State Machine.
<span class="nc" id="L869">      return firstAvailable;</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">    } else if (leaderStartIndex == RaftLog.INVALID_LOG_INDEX) {</span>
      // Leader has no logs to check from, hence return next index.
<span class="nc" id="L872">      return firstAvailable;</span>
    }

<span class="nc" id="L875">    return null;</span>
  }

  static class AppendEntriesRequest {
    private final Timekeeper timer;
    @SuppressWarnings({&quot;squid:S3077&quot;}) // Suppress volatile for generic type
    private volatile Timekeeper.Context timerContext;

    private final long callId;
    private final TermIndex previousLog;
    private final int entriesCount;

    private final TermIndex firstEntry;
    private final TermIndex lastEntry;
    @SuppressWarnings({&quot;squid:S3077&quot;}) // Suppress volatile for generic type
    private volatile Timestamp sendTime;

<span class="nc" id="L892">    AppendEntriesRequest(AppendEntriesRequestProto proto, RaftPeerId followerId, GrpcServerMetrics grpcServerMetrics) {</span>
<span class="nc" id="L893">      this.callId = proto.getServerRequest().getCallId();</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">      this.previousLog = proto.hasPreviousLog()? TermIndex.valueOf(proto.getPreviousLog()): null;</span>
<span class="nc" id="L895">      this.entriesCount = proto.getEntriesCount();</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">      this.firstEntry = entriesCount &gt; 0? TermIndex.valueOf(proto.getEntries(0)): null;</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">      this.lastEntry = entriesCount &gt; 0? TermIndex.valueOf(proto.getEntries(entriesCount - 1)): null;</span>

<span class="nc" id="L899">      this.timer = grpcServerMetrics.getGrpcLogAppenderLatencyTimer(followerId.toString(), isHeartbeat());</span>
<span class="nc" id="L900">      grpcServerMetrics.onRequestCreate(isHeartbeat());</span>
<span class="nc" id="L901">    }</span>

    long getCallId() {
<span class="nc" id="L904">      return callId;</span>
    }

    TermIndex getPreviousLog() {
<span class="nc" id="L908">      return previousLog;</span>
    }

    long getFirstIndex() {
<span class="nc" id="L912">      return Optional.ofNullable(firstEntry).map(TermIndex::getIndex).orElse(RaftLog.INVALID_LOG_INDEX);</span>
    }

    Timestamp getSendTime() {
<span class="nc" id="L916">      return sendTime;</span>
    }

    void startRequestTimer() {
<span class="nc" id="L920">      timerContext = timer.time();</span>
<span class="nc" id="L921">      sendTime = Timestamp.currentTime();</span>
<span class="nc" id="L922">    }</span>

    void stopRequestTimer() {
<span class="nc" id="L925">      timerContext.stop();</span>
<span class="nc" id="L926">    }</span>

    boolean isHeartbeat() {
<span class="nc bnc" id="L929" title="All 2 branches missed.">      return entriesCount == 0;</span>
    }

    @Override
    public String toString() {
<span class="nc bnc" id="L934" title="All 4 branches missed.">      final String entries = entriesCount == 0? &quot;&quot;</span>
          : entriesCount == 1? &quot;,entry=&quot; + firstEntry
          : &quot;,entries=&quot; + firstEntry + &quot;...&quot; + lastEntry;
<span class="nc" id="L937">      return JavaUtils.getClassSimpleName(getClass())</span>
          + &quot;:cid=&quot; + callId
          + &quot;,entriesCount=&quot; + entriesCount
          + entries;
    }
  }

<span class="nc" id="L944">  static class RequestMap {</span>
<span class="nc" id="L945">    private final Map&lt;Long, AppendEntriesRequest&gt; logRequests = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L946">    private final Map&lt;Long, AppendEntriesRequest&gt; heartbeats = new ConcurrentHashMap&lt;&gt;();</span>

    int logRequestsSize() {
<span class="nc" id="L949">      return logRequests.size();</span>
    }

    void clear() {
<span class="nc" id="L953">      logRequests.clear();</span>
<span class="nc" id="L954">      heartbeats.clear();</span>
<span class="nc" id="L955">    }</span>

    void put(AppendEntriesRequest request) {
<span class="nc bnc" id="L958" title="All 2 branches missed.">      if (request.isHeartbeat()) {</span>
<span class="nc" id="L959">        heartbeats.put(request.getCallId(), request);</span>
      } else {
<span class="nc" id="L961">        logRequests.put(request.getCallId(), request);</span>
      }
<span class="nc" id="L963">    }</span>

    AppendEntriesRequest remove(AppendEntriesReplyProto reply) {
<span class="nc" id="L966">      return remove(reply.getServerReply().getCallId(), reply.getIsHearbeat());</span>
    }

    AppendEntriesRequest remove(long cid, boolean isHeartbeat) {
<span class="nc bnc" id="L970" title="All 2 branches missed.">      return isHeartbeat ? heartbeats.remove(cid): logRequests.remove(cid);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>